### Tree

Node와 Edge로 이루어진 자료 구조이다.

![](https://camo.githubusercontent.com/0c5d88f9ab9e87e19886f5a9bd5dbcb7f4303e9c6c2ab9b06688603796957d1f/68747470733a2f2f7777772e6765656b73666f726765656b732e6f72672f77702d636f6e74656e742f75706c6f6164732f62696e6172792d747265652d746f2d444c4c2e706e67)

트리는 값을 가진 노드(Node)와 이 노드들을 연결해주는 간선(Edge)로 이루어져 있다.
그림 상 데이터 1을 가진 노트가 루트(Root) 노드다.
모든 노드들은 0개 이상의 자식(Child) 노드를 갖고 있으며 보통 부모-자식 관계로 부른다.

### 트리의 특징

-  트리에는 사이클이 존재할 수 없다. 만약 사이클이 만들어진다면 그것은 트리가 아닌 그래프이다.
-  모든 노드는 자료형으로 표현이 가능하다.
-  루트에서 한 노드로 가는 경로는 유일하다.
-  노드의 개수가 N개면, 간선은 N-1개를 가진다.

> 사이클이 존재하지 않는 그래프라 하여 무조건 트리인 것은 아니다. 사이클이 존재하지 않는 그래프는 Forest라 지칭하며 트리의 경우 싸이클이 존재하지 않고 모든 노드가 간선으로 이어져 있어야 한다.

### 트리 순회 방식

트리를 순회하는 방식은 총 4가지가 존재한다. 아래의 그림을 예시로 알아보자.

![](https://camo.githubusercontent.com/0c5d88f9ab9e87e19886f5a9bd5dbcb7f4303e9c6c2ab9b06688603796957d1f/68747470733a2f2f7777772e6765656b73666f726765656b732e6f72672f77702d636f6e74656e742f75706c6f6164732f62696e6172792d747265652d746f2d444c4c2e706e67)

1. 전위 순회(pre-order)
	각 부모 노드를 순차적으로 먼저 방문하는 방식이다.
	(부모 -> 왼쪽 자식 -> 오른쪽 자식)
	1 -> 2 -> 4 -> 8 -> 9 -> 5 -> 10 -> 11 -> 3 -> 6 -> 13 -> 7 -> 14

2. 중위 순회(in-order)
	왼쪽 하위 트리를 방문 후 부모 노드를 방문하는 방식이다.
	(왼쪽 자식 -> 부모 -> 오른쪽 자식)
	8 -> 4 -> 9 -> 2 -> 10 -> 5 -> 11 -> 1 -> 6 -> 13 -> 3 -> 14 -> 7

3. 후위 순회(post-order)
	왼쪽 하위 트리부터 하위를 모두 방문 후 부모 노드를 방문하는 방식이다.
	(왼쪽 자식 -> 오른쪽 자식 -> 부모)
	8 -> 9 -> 4 -> 10 -> 11 -> 5 -> 2 -> 13 -> 6 -> 14 -> 7 -> 3 -> 1

4. 레벨 순회(level-order)
	부모 노드부터 계층 별로 방문하는 방식이다.
	1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10 -> 11 -> 13 -> 14

```java
public class Tree<T> {
    private Node<T> root;

    public Tree(T rootData) {
        root = new Node<T>();
        root.data = rootData;
        root.children = new ArrayList<Node<T>>();
    }

    public static class Node<T> {
        private T data;
        private Node<T> parent;
        private List<Node<T>> children;
    }
}
```