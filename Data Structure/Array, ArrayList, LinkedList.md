![](https://camo.githubusercontent.com/30d51427a6a8b40896aa70554a9db341f5b4742815dc334ab435b95d360b84dc/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f393935453636333935423143464437443130)

![](https://camo.githubusercontent.com/6ad98d232096eb764e6feb58d6fa0716791502d3c9534fb366fd615405d70f1e/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f393932353041333435423143464436393043)

### Array, ArrayList, LinkedList의 대표적 특징

- Array는 index값을 이용하여 빠르게 값을 찾는 것이 가능하다.
- LinkedList는 데이터의 삽입 및 삭제가 빠르다.
- ArrayList는 데이터를 찾는데 빠르지만, 삽입 및 삭제가 느리다.

좀 더 자세하게 알아보자.

**배열(Array)** 은 선언과 동시에 크기와 데이터 타입을 지정해주어야 한다.

```java
int arr[10];
String arr[5];
```

위와 같이 Array는 메모리 공간에 할당할 사이즈를 미리 정해놓고 사용하는 자료구조이다.
따라서 계속 데이터가 늘어날 경우, 최대 사이즈를 알 수 없을 경우에는 사용하기에 부적합하다고 할 수 있다.
중간에 데이터를 삽입하거나 삭제할 때에도 매우 비효율적인데, 4번째 index에 새로운 값을 넣는다고 가정했을 때 원래 값을 뒤로 밀어내고 해당 index에 덮어씌워줘야 한다. 기본적으로 사이즈를 정해놓은 배열에서 해결하기엔 부적합한 점이 많다. 대신 index가 존재하기에 위치를 바로 찾을 수 있어 검색에 편리하다.

이를 해결하기 위해서 나온것이 **List**이다

List는 Array처럼 크기를 정해주지 않아도 된다. 대신 Array에서 index가 중요했다면, List에선 순서가 중요하다. 크기가 정해져있기 않기 때문에, 중간에 데이터를 추가하거나 삭제하더라도 Array에서 갖고 있던 문제점들을 해결 가능하다. index도 가지고 있기 때문에 검색도 빠르다.

하지만, 중간에 데이터를 추가 및 삭제할 경우 시간이 오래걸리는 단점이 존재한다. 더하거나 뺄때마다 줄줄이 당겨지거나 밀려날 때 진행되는 연산이 추가, 메모리도 낭비된다.

**LinkedList** 는?

연결리스트에는 단일, 다중 등 여러가지가 존재한다.
종류가 무엇이든, 한 노드에 연결될 노드의 포인터 위치를 가리키는 방식으로 되어있다.

> 단일은 뒤의 노드만 가리키고 다중은 앞뒤 노드를 모두 가리키는 차이

이런 방식을 활용하면서, 데이터의 중간에 삽입/삭제를 하더라도 전체를 돌지 않고 이전 값과 다음 값이 가르켰던 주소값만 수정하여 연결시켜주기 때문에 효율적이다.

하지만, index를 갖고있지 않아 처음부터 순차적으로 접근해야 하므로 검색에 있어서는 시간이 걸린다는 단점이 있다.