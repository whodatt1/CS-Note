## 사전 지식

### 세션 (Session)

유저가 웹브라우저를 키고 네이버 서버에 www.naver.com (GET) 으로 요청을 한다고 가정하자. 서버는 해당 주소에 맞는 컨트롤러의 메서드를 찾는다. 그리고 그 메소드에서 메인 페이지에 맞는 .html 파일을 리턴한다. 이때 http header 쿠키라는 것을 만든다. Java면 세션ID를 만든다. 1234 라고 가정하자. 그럼 웹 브라우저는 이 세션ID를 받아서 어떤 특정한 일을 하지 않더라도 이 웹 브라우저의 쿠키라는 저장 영역에 세션ID가 담긴다. 이 것은 최초 요청 시에 만들어진다. 만약 클라이언트 최초 요청이 아니면 두 번째 요청부터는 세션ID를 헤더에 달고 간다. 서버는 다시 생성하는 것이 아니라 해당 세션을 다시 돌려준다. 서버는 세션ID를 줄 때마다 해당 데이터를 목록으로 만들어서 관리를 한다. 

즉, 클라이언트 최초 요청 시 서버는 세션 목록에 세션ID를 만들고 해당 세션ID를 헤더에 담아서 돌려준다. 두 번째 요청 시 클라이언트에 저장된 세션 ID를 들고간다고 할때 서버는 목록에 있다면 통과가 되고 없거나 잘못된 값이 들어올 경우 새로운 세션 ID를 만들고 헤더아 담아서 돌려준다. 연결을 끊을 수 있는 방법은 첫번째는 서버에서 세션 값을 날릴경우 연결이 끊긴다. 두번째는 브라우저를 모두 종료하는 것이다. 두번째의 경우 서버의 세션 값이 사라지진 않지만 새로 요청시 새로운 세션으로 인식하여 새로 발급된다. 남은 쓰레기 값은 30분 정도 후에 삭제된다. 세번째는 특정 시간이 지날 경우이다. (보통 30분)

이러한 세션에는 단점이 있다. 보통 인증이 필요한 로그인 요청을 할 때 많이 사용이 된다. 클라이언트가 서버에 리퀘스트를 했다고 가정하자. 이때 서버는 세션이라는 저장정보에 세션 아이디를 만들고 해당 세션 아이디에 저장소가 생긴다. 최초의 요청이 들어오고 나서 응답을 해줄 때 헤더에 세션ID를 돌려준다. 그럼 클라이언트 쪽 웹 브라우저에 세션ID가 저장이 된다. 이후 로그인 요청을 한다. test, 1234로 로그인 했다고 치면 DB에서 확인을 하여 정상이면 세션ID 저장소에 DB 유저 정보를 저장한다. 보통 로그인이 성공을 하면 메인페이지(html)로 이동하게 되는데 이후 어떤 인증이 필요한 페이지를 요청할 경우 이때 인증정보를 확인해야하니 클라이언트에서 세션 정보를 담아 보낸다. 서버 쪽 세션ID 저장소에 정보가 있다면 DB 사용자 정보를 응답받고 돌려주게 된다.

결국 세션의 단점은 클라이언트가 서버에 리퀘스트할 때 서버에서 정보를 응답해 줄 수 있는데 예를 들어 클라이언트가 100만명이고 동시접속자수가 300명이며 우리 서버는 100명만 처리할 수 있는 서버 3개를 가지고 있다고 가정해보자. 만약 1번 서버에 세션을 받고 재요청하는 것엔 문제가 없다. 하지만 로드밸런싱이 발생하여 3번 서버에 1번 서버에 받은 세션ID를 보낸다면 서버3은 해당 사용자가 처음 온 사람으로 인식할 것이다.  이 부분은 스티키 세션같은 방법으로 해결하거나 DB를 공유하여 해당 DB에 세션 값을 가져온다. 스티키 세션같은 경우엔 세션을 받은 서버에만 재요청을 하게끔 하기 때문에 해당 서버의 과부하가 올 수 있고 DB에서 해당 처리를 할 경우 메모리에서 찾는 것보다 속도가 확연히 느려지게 된다. 그래서 보통 메모리 공유 서버를 사용한다. 메모리 서버를 쓰면 I/O가 일어나지 않는다. 그래서 모든 서버가 메모리 공유 서버에 세션값을 저장해놓고 같이 공유해서 사용한다. 해당 서버는 꼭 메모리 램이어야 한다. 대표적으로 Redis라는 서버가 있다.

### TCP

웹에는 OSI 7 계층이 있다. 이 7 계층은 물리 계층, 데이터링크 계층, 네트워크 계층, 트랜스포트 계층, 세션 계층, 프레젠테이션 계층, 응용 계층으로 나뉜다. 통신을 하기 위해서는 항상 응용 계층부터 물리 계층 까지 내려가서 물리 계층에서 전송이 되며 상대에게 전송이 되면 거꾸로 물리 계층으로부터 시작하여 응용 계층까지 올라가게 된다. 프로그램 자체가 응용 계층이다. 데이터를 던지기 전 암호화 혹은 압축이 되는 구간이 프레젠테이션 계층이다. 데이터를 보내기 위한 인증 여부를 검사하는 곳이 세션 계층이다. 트랜스포트 계층은 TCP/UDP 통신을 결정한다. TCP 통신은 신뢰성 있는 통신이다. 보낸 데이터가 잘 갔는지 항상 확인(ACK)을 한다. UDP는 신뢰성이 없는 통신이다. 확인(ACK) 과정 없이 데이터를 전송한다. 보통 전화할 때에 UDP 통신을 쓴다. 만약 비밀번호 ID를 보내게 됐다고 가정한다. 이 경우 데이터가 유실되면 안된다. 해서 신뢰성이 필요한 TCP 통신을 사용한다. 웹은 TCP 통신을 사용한다. 네트워크 계층은 IP를 결정한다. IP를 알아야 상대방을 찾을 수 있다. 데이터링크 계층부터는 내부 통신인 LAN을 담당한다. 이전은 WAN.  물리 계층을 광케이블과 같은 전송 선이다. 이러한 계층을 거쳐 데이터를 주고 받게 된다.

### 보안

A와 B, C라는 나라가 있다고 가정하자. A와 B가 동맹을 맺은 상황이다. 여기서 A가 B에게 중요한 문서를 전달 한다고 했을 때 아무런 대책 없이 들고 가다가 C나라로부터 해당 문서를 강탈 당하게 되었다. 이렇게 되면 C는 A가 B에게 전달하려고 한 문서를 볼 수 있다. 여기서 C나라가 해당 문서를 가로챔으로 인해 기밀성, 무결성, 가용성이라는 정보 보안의 기본요 요소가 모두  깨지게 된다.(CIA) 기밀성은 문서의 내용이 허가된 사람만 볼 수 있어야 한다는 원칙을 의미하고, 무결성은 문서의 내용이 변경되지 않아야 한다는 원칙을 의미하며, 가용성은 문서가 필요한 사람에게 언제든지 접근 가능해야 한다는 원칙을 의미한다. 기밀성을 지키기 위한 방법은 문서를 암호화 하는 것이다. 가용성과 무결성을 지키기 위한 방법은 해당 암호화된 문서를 복호화할 키를 주는 것이다. 안전한 응답을 받기 위해서는 복호화 키 전달 문제와 누구로부터 해당 문서가 왔는지를 중점으로 두어야한다.

### RSA(암호화)

키를 두 가지를 가지고 있다. Public key(공개키) 와 Private Key(개인키)가 있다. A와 B가 있다. 그리고 그 사이 C가 있다고 가정하자. A 가 B에게 특정 문서를 전달하고자 한다. C는 이것을 가로챌 가능성이 있다. 이때 A가 해당 문서를 암호화 하여 보낸다. 이때 B가 받기 위해선 해당 문서가 B가 만든 자신의 공개키로 암호화가 되어야 한다. A와 B는 각각 공개키와 개인키를 가지고 있다.  B는 자신의 공개키로 암호화된 문서를 자신의 개인키로 복호화 할 수 있다. 반대로 B가 메시지를 A에게 보내고 싶으면 B는 특정 문서를 A의 공개키로 암호화하여 A에게 전달하면 된다. 이로 인해 복호화 키 전달 문제를 해결할 수 있다. A가 C에게 1억을 송금했다는 내용의 문서를 B에게 보내려고 한다. 이때 해당 문서를 A의 개인키로 암호화를 한다. 이때 A의 개인키로 잠궜기 때문에 C는 A의 공개키로 해당 문서를 복호화 하여 해당 문서를 볼 수 있다. 이 때 B는 A의 공개키로 해당 문서를 열어보면 해당 내용을 확인할 수 있다. 이때 B는 해당 문서는 A가 적은 글이 맞다는 걸 확인할 수 있다. 이유는 A의 개인키로 문서를 잠글 수 있는 건 A 본인밖에 없기 때문이다. 개인키로 잠근다는 것은 전자문서의 서명 즉 인증을 의미한다. 이로 인해 인증 문제를 해결할 수 있다.

공개키 -> 개인키 (암호화)
개인키 -> 공개키 (전자서명)

최종적으로 A가 어떠한 중요한 문서를 B에게 보낸다고 할때 A개인키(B공개키(내용)) 방식으로 감싸서 전송하게 된다.

1. B가 문서를 받는다.
2. A의 공개키로 해당 문서를 열어본다. (열린다면 인증 해결)
3. B의 개인키로 해당 문서를 열어본다. (암호화 문제 해결)

### RFC

벨 연구소에서 내부망을 구축해서 통신하고 있었다. 예를 들어 A 대학에서 똑같이 내부망을 구성하였다. 여기서 A 대학이 벨 연구소와 통신을 하고 싶은데 약속을 하고 만든 내부망이 아니기 때문에 내부망 구성이 각각 달랐다. 통신을 하고 싶다면 약속된 규칙이 있어야 한다. 이때 약속된 규칙 최초의 문서가 RFC 1번 문서이다. 그리고 이 문서를 프로토콜이라고 한다. B대학도 이들과 같이 통신을 하고 싶다고 했을 때 RFC 2번 문서가 생성되게 된다. 이렇게 점점 네트워크가 연결이 될때마다 문서가 하나씩 생기게 되는데 이로 인해 RFC 2515 과 같이 새로운 문서가 만들어지게 된다. 이런 네트워크들이 계속 모여 만들어 진것이 WWW 인터넷이라고 한다. 즉 인터넷은 RFC 문서들로 만들어져 있다. 이 약속의 프로토콜이 http 프로토콜이다. 네트워크 망이 비대해진 지금 새로운 RFC 문서를 만든다고 할 때 기존 네트워크 망이 하여금 동의를 받아야 만들어 질 수 있다. 점점 규약들이 많이 생기게 되었다.

### JWT

JSON 객체로 안전하게 정보를 전송하기 위한 방식이다. 디지털 서명이 되어있으므로 신뢰할 수 있다. JWT는 HMAC 알고리즘 또는 RSA를 사용한다.

JWT를 암호화하여 비밀의 메세지를 보낼 수도 있지만 서명된 토큰에 중점을 둔다. 서명된 토큰은 그 안에 클레임이란 정보가 있는데 이 정보의 무결성을 확인할 수 있게 해준다.

JWT의 구조는

xxxxx.yyyyy.zzzzz

Header, Payload, Signature로 구성된다.
JSON은 Base64Url로 인코딩 되어있다. 암호화와 복호화 가능

Header는 일반적으로 토큰 유형(JWT)과 사용중인 서명 알고리즘으로 구성된다.

Payload는 등록된 클레임과 개인 클레임으로 이루어진다. 등록된 클레임은 필수는 아니지만 권장되는 미리 정의된 클레임 집합

우리는 개인클레임에 user정보에 필요한 primary key를 넣어둘 것

sub, name 등록된 클레임 이외의 키와 밸류 값을 넣을 수 있다.

마지막으로 서명 부분에는 헤더와 페이로드 정보와 시크릿키 정보값을 넣는다.(HMAC으로 암호화하여)

서버와 클라이언트가 있다고 가정해보자. 클라이언트가 아이디 kim과 비밀번호 1234로 로그인 시도를 했다고 하자. 이때 서버가 header, payload, signature를 만든다. header에는 HS256으로 서명을 했다는 정보, payload에는 username: kim이란 정보가 저장되어있고 signature에는 header + payload 에 서버만 알고 있는 키(시크릿키) 값을 포함하여 HS256으로 암호화를 한다.

HS256은 **HMAC** 방식으로 **SHA-256** 해시 알고리즘을 사용하는 암호화 기법이다. **HMAC**은 메시지 인증을 위해 사용되며, 시크릿 키(비밀 키)를 포함하여 해시 값을 생성하는 방식이다.

이렇게 암호화를 하여 각각을 BASE64로 인코딩 하게 된다. 그리고 이것을 클라이언트에게 돌려준다.

이때 해당 난수 정보를 클라이언트 로컬 스토리지같은 영역에 보관한다. 

클라이언트에서 서버에 개인정보를 요청할때 로컬 스토리지에 저장된 JWT를 실어서 보낸다.

이때 서버는 신뢰할 수 있는 토큰인지 검증이 필요하다.

header와 payload + 시크릿키를 HS256으로 암호화 해봤을때 로컬 스토리지 난수와 같다면 인증이 가능해진다.

이후 payload의 정보를 DB에서 SELECT 하여 정보를 보내준다.

만약 HS256이 아닌 RSA를 사용한다면 header에 RSA라는 정보가 들어간다.

이 경우 signature를 만들때 시크릿키가 필요없다. header와 payload를 서버의 개인키로 잠궈서 signature를 만든다.

클라이언트에서 해당 토큰을 서버에 던지면 검증시 공개키로 해당 시그니처를 열어서 서명을 검증하면 된다.

보통 HS256을 많이 사용한다.

서버 입장에선 이제 세션을 사용하지 않기 때문에 JWT 토큰 시크릿 키만 알고있으면 된다.

JWT는 아무나 만들수 없다 서버가 만들어야만 유효한 값이 되기 때문이다.